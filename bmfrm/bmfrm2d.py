import numpy as np
class bmfrm2d:
    """Class object defining a beamformer. Needs the following parameters defined...

    Parameters:
    ----
    Nt: number of time samples per RF line (int)
    dt: sampling period of channel data [s]
    tstart: start time of rf line [s]
    usf: upsample factor (int) newsamples/old
    nele: number of elements in transducer
    dele: element pitch [m]
    Nlat: number of lateral, reconstructed pixels (int)
    dlat: lateral spacing of pixels [m]
    Nax: number of axial pixels (int)
    dax: spacing between axial pixels [m]
    ulc: spatial location of upper left corner [m, m]
    apod: apodization function (default None)
    fnum: fnumber used in recon (default None)
    """
    def __init__(self):
        """Initialize the beamformer with needed parameters"""
        self.Nt = None
        self.dt = None
        self.tstart = None
        self.usf = None
        self.nele = None
        self.dele = None
        self.Nlat = None
        self.dlat = None
        self.Nax = None
        self.dax = None
        self.ulc = None
        self.apod = None
        self.fnum = None
        self.txparams = None
        self.c = None
        self.dtpulse = 0

    def verifyparams(self):
        """Verify parameters. Should be called after all required feilds are filled"""
        pass

    def gentabs(self):
        # Verify this beamformer has been instantiated properly
        self.verifyparams()

        # Calculate the lateral position of elements, and the axial/lateral coordinates of recon pixels
        self.posele = np.linspace(-self.dele*(self.nele-1)/2, self.dele*(self.nele-1)/2, self.nele)
        self.posax = np.linsapce(self.ulc[0], self.ulc[0] + self.Nax*self.dax, self.Nax)
        self.poslat = np.linsapce(self.ulc[1], self.ulc[1] + self.Nlat*self.dlat, self.Nlat)
        self.t = self.tstart + self.dt * np.arange(self.Nt*self.usf + 1) / self.usf # one additional data point to set to zero
        
        # Call the relevant helper function based on the transmit mode being used
        if self.txparams['mode'] == 'planewave':
            try:
                from bmfrm.bmfrm2d import __pwcalctabs__
                __pwcalctabs__(self)
            except Exception as e:
                raise Exception("An error occured when using 'planewave' mode beamformer") from e
        elif self.txparams['mode'] == 'alines':
            try:
                from bmfrm.bmfrm2d import __alinecalctabs__
                __alinecalctabs__(self)
            except Exception as e:
                raise Exception("An error occured when using 'aline' mode beamformer") from e
        else:
            raise Exception("Unknown beamforming mode")

    def genmasks(self):
        pass

def __pwcalctabs__(self : bmfrm2d):
    """Generates the indices of the upsampled time trace for each element
    
    The tabs are generated by summing together three times of flight (TOF):
     - TOF from t=0 to each point's incidence with the wave front
     - TOF from each point's location the to given element
     - the amount of time from t=0 ultil the peak envelope of the pulse
    """
    # import needed trig engines
    from bmfrm.trigengines import rxengine, pwtxengine

    # generate X, Y, and Z grids (Y is a grid of zeros)
    X, Y, Z = np.meshgrid(self.poslat, np.array([0]), self.posax, indexing='xy')
    points = np.array([X.flatten(order='f'), Y.flatten(order='f'), Z.flatten(order='f')]).T
    del X, Y, Z

    # make an empty buffer to hold delay tabs
    self.tabs = np.zeros((points.shape[0], self.nele), order = 'f')

    # for each receive element...
    for inde, elex in enumerate(self.posele):
        # calculate the delay from t=0 in seconds
        print('WARNING tref and theta need to be actually calculated or referenced for steered plane waves')
        ref = np.array([[elex, 0, 0]])
        taus = rxengine(self.c, ref=ref, points = points)
        taus += pwtxengine(self.c, tref=0, theta=0, phi=0, ref=ref, points=points)
        taus += self.dtpeak

        # convert time to indices of the upsampled time vector
        tabs = np.zeros(len(taus))
        for indt, tau in enumerate(taus):
            tabs[indt] = np.argmin(np.abs(self.t - tau))
        self.tabs[:, inde] = tabs

def __pwcalcmasks__(self : bmfrm2d):
    pass

def __alinecalctabs__(self : bmfrm2d):

    pass
